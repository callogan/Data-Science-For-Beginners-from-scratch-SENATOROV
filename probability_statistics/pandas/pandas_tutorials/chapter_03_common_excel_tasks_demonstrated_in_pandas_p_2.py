"""Common Excel tasks, demonstrated in pandas (part 2)."""

# # Типичные задачи Excel, продемонстрированные в pandas (часть 2)

# ## Введение
#
# В [первой статье](https://dfedorov.spb.ru/pandas/%D0%A2%D0%B8%D0%BF%D0%B8%D1%87%D0%BD%D1%8B%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20Excel,%20%D0%BF%D1%80%D0%BE%D0%B4%D0%B5%D0%BC%D0%BE%D0%BD%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%B2%20pandas.html) я сосредоточился на распространенных математических задачах, выполняемых в Excel, и их аналогах в pandas. В этой статье я сосредоточусь на некоторых типичных задачах выбора и фильтрации и покажу, как сделать то же самое в pandas.
#
# > Оригинал статьи Криса по [ссылке](https://pbpython.com/excel-pandas-comp-2.html).

# ## Подготовка к настройке 
#
# Импортируйте модули pandas и numpy:

# import numpy as np
import pandas as pd

# Загрузите данные в формате Excel, представляющие годовой объем продаж компании:

# +
# pylint: disable=line-too-long

df = pd.read_excel(
    "https://github.com/dm-fedorov/pandas_basic/blob/master/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5%20%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%20pandas/data/sample-salesv3.xlsx?raw=True"
)
df.head()
# -

# Взгляните на типы данных, чтобы убедиться, что все прошло должным образом:

df.dtypes

# Видим, что столбец `date` отображается как `object`, т.е. как строка. Преобразуем его в `datetime`, чтобы упростить себе задачу в дальнейшем:

df["date"] = pd.to_datetime(df["date"])
df.head()

df.dtypes

# ## Фильтрация данных
#
# Думаю, что одна из самых удобных функций Excel - это фильтр. Полагаю, что каждый раз, когда кто-то получает Excel файл любого размера и хочет отфильтровать данные, он пользуется функцией `filter`.
#
# Вот изображение ее использования для представленного набора данных:

# ![](https://github.com/dm-fedorov/pandas_basic/blob/master/pic/excel-filter.png?raw=True)

# Подобно функции фильтрации в Excel, вы можете использовать pandas для фильтрации и выбора определенных подмножеств данных.
#
# Например, если мы хотим просто увидеть конкретный номер учетной записи, то можем легко сделать это с помощью Excel или pandas.
#
# Вот решение для фильтрации в Excel:

# ![](https://github.com/dm-fedorov/pandas_basic/blob/master/pic/excel-filter2.png?raw=True)

# В pandas это сделать относительно просто. 
#
# Обратите внимание, что я использую функцию `head` для показа верхних результатов. Это сделано исключительно для того, чтобы статья выглядела короче:

df[df["account number"] == 307599].head()

# Вы также можете выполнить фильтрацию на основе числовых значений. Я не собираюсь больше приводить примеры в Excel. Уверен, что вы уловили идею.

df[df["quantity"] > 22].head()

# Если мы хотим выполнить более сложную фильтрацию, то можем использовать функцию `map` для фильтрации по различным критериям. 
#
# В следующем примере давайте поищем товары с артикулами, начинающимися с `B1`:

df[df["sku"].map(lambda x: x.startswith("B1"))].head()

# С помощью `&` легко связать два или более операторов в цепочку:

df[df["sku"].map(lambda x: x.startswith("B1")) & (df["quantity"] > 22)].head()

# Еще одна полезная функция, которую поддерживает pandas, называется `isin`. Она позволяет определить список значений, которые мы хотим найти.
#
# Далее мы ищем все записи, которые включают два номера счетов:

df[df["account number"].isin([714466, 218895])].head()

# Pandas поддерживает другую функцию, называемую `query`, которая позволяет эффективно выбирать подмножества данных. Она требует установки [`numexpr`](https://github.com/pydata/numexpr), поэтому убедитесь, что этот модуль установлен, прежде чем пытаться выполнить следующий шаг.
#
# Если вы хотите получить список клиентов по имени, то можете сделать это с помощью запроса (`query`), аналогичного синтаксису Python, показанному выше:

df.query('name == ["Kulas Inc","Barton LLC"]').head()

# Функция `query` позволяет сделать значительно больше, чем показано в этом простом примере.
#
# ## Работа с датами 
#
# Используя pandas, вы можете выполнять сложную фильтрацию по датам. Прежде чем делать что-либо с датами, я рекомендую отсортировать их по столбцу даты, чтобы убедиться, что результаты возвращают то, что вы ожидаете:

df = df.sort_values(by=["date"])
df.head()

# Синтаксис фильтрации Python, показанный ранее, работает с датами:

df[df["date"] >= "20140905"].head()

# Одна из действительно полезных особенностей pandas - это то, что он понимает даты, что позволяет нам выполнять частичную фильтрацию. 
#
# Если хотим найти данные, начиная с определенного месяца:

df[df["date"] >= "2014-03"].head()

# Конечно, можно объединить критерии фильтрации:

df[(df["date"] >= "20140701") & (df["date"] <= "20140715")].head()

# Поскольку pandas понимает столбцы с датами, то вы можете выразить значение даты в разных форматах:

df[df["date"] >= "Oct-2014"].head()

df[df["date"] >= "10-10-2014"].head()

# При работе с временными рядами, если мы установим даты в качестве индекса, то можем выполнить еще несколько видов фильтрации.
#
# Установите новый индекс с помощью функции `set_index`:

df2 = df.set_index(["date"])
df2.head()

# Выполним срез (`slic`), чтобы получить диапазон:

df2.index = pd.to_datetime(df2.index)
df2["20140101":"20140201"].head()  # type: ignore

# Еще раз, мы можем использовать различные представления даты, чтобы устранить любую двусмысленность в соглашениях об именах дат:

df2.index = pd.to_datetime(df2.index)
df2["2014-Jan-1":"2014-Feb-1"].head()  # type: ignore

df2.index = pd.to_datetime(df2.index)
df2["2014-Jan-1":"2014-Feb-1"].tail()  # type: ignore

df2.loc["2014"].head()

df2.loc["2014-Dec"].head()

# Как видите, существует множество вариантов сортировки и фильтрации по датам.

# ## Дополнительные строковые функции
#
# Pandas также поддерживает векторизованные строковые функции.
#
# Если мы хотим идентифицировать все артикулы (`sku`), содержащие определенное значение, то можем использовать `str.contains`. В этом случае мы знаем, что артикул всегда представлен одинаково, поэтому `B1` отображается только перед артикулом:

df[df["sku"].str.contains("B1")].head()

# Мы можем объединить запросы и использовать `sort_values` для управления порядком данных:

df[(df["sku"].str.contains("B1-531")) & (df["quantity"] > 40)].sort_values(
    by=["quantity", "name"], ascending=[False, True]
)

# ## Бонусная задача 
#
# Я часто пытаюсь получить список уникальных элементов в виде длинного списка в Excel. Это многоступенчатый процесс в Excel, но в pandas это довольно просто. 
#
# Вот один из способов сделать это с помощью расширенного фильтра в Excel:
#
# ![](https://github.com/dm-fedorov/pandas_basic/blob/master/pic/excel-filter3.png?raw=True)

# В pandas используем функцию `unique` для столбца, чтобы получить список: 

df["name"].unique()

# Если бы мы хотели включить `account number` (номер учетной записи), то могли бы использовать [`drop_duplicates`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html):

df.drop_duplicates(subset=["account number", "name"]).head()

# Очевидно, что мы собираем больше данных, чем нам нужно, и получаем некоторую бесполезную информацию, поэтому выберите только первый и второй столбцы с помощью `iloc`:

print(df.drop_duplicates(subset=["account number", "name"]).iloc[:, [0, 1]])

# Думаю, что эту команду легче сохранить, чем пытаться каждый раз запоминать шаги Excel.

# ## Заключение
#
# После того, как я опубликовал свою первую статью, Дэйв Проффер (Dave Proffer) ретвитнул мой пост и сказал: «Хорошие советы избавляют нас от #excel зависимости». Я думаю, что это точный способ описать, как часто используется Excel сегодня. Множество людей сразу тянутся к Excel, не осознавая, насколько это может быть ограничивающим. Я надеюсь, что эта серия статей поможет людям понять, что существуют альтернатива и `python + pandas - чрезвычайно мощная комбинация`.
